diff --git a/pvlib/tools.py b/pvlib/tools.py
index e3f7b2d..a4c9f9f 100644
--- a/pvlib/tools.py
+++ b/pvlib/tools.py
@@ -338,37 +338,44 @@ def _golden_sect_DataFrame(params, lower, upper, func, atol=1e-5):
 
     phim1 = (np.sqrt(5) - 1) / 2
 
-    df = params
-    df['VH'] = upper
-    df['VL'] = lower
-
-    converged = False
-    iterations = 0
-
-    # handle all NaN case gracefully
-    with warnings.catch_warnings():
-        warnings.filterwarnings(action='ignore',
-                                message='All-NaN slice encountered')
-        iterlimit = 1 + np.nanmax(
-            np.trunc(np.log(atol / (df['VH'] - df['VL'])) / np.log(phim1)))
-
-    while not converged and (iterations <= iterlimit):
-
-        phi = phim1 * (df['VH'] - df['VL'])
-        df['V1'] = df['VL'] + phi
-        df['V2'] = df['VH'] - phi
-
-        df['f1'] = func(df, 'V1')
-        df['f2'] = func(df, 'V2')
-        df['SW_Flag'] = df['f1'] > df['f2']
-
-        df['VL'] = df['V2']*df['SW_Flag'] + df['VL']*(~df['SW_Flag'])
-        df['VH'] = df['V1']*~df['SW_Flag'] + df['VH']*(df['SW_Flag'])
-
-        err = abs(df['V2'] - df['V1'])
-
-        # works with single value because err is np.float64
-        converged = (err[~np.isnan(err)] < atol).all()
-        # err will be less than atol before iterations hit the limit
-        # but just to be safe
-        iterations += 1
+    df = params.copy()
+    df['VH'] = upper
+    df['VL'] = lower
+
+    # If upper and lower bounds are equal, return the function value at that point
+    if np.allclose(df['VH'], df['VL']):
+        v = df['VH']
+        f_val = func(df.assign(V1=v), 'V1')
+        # Return a tuple with the power and voltage at max power point
+        return f_val, v
+
+    converged = False
+    iterations = 0
+
+    # handle all NaN case gracefully
+    with warnings.catch_warnings():
+        warnings.filterwarnings(action='ignore',
+                                message='All-NaN slice encountered')
+        iterlimit = 1 + np.nanmax(
+            np.trunc(np.log(atol / (df['VH'] - df['VL'])) / np.log(phim1)))
+
+    while not converged and (iterations <= iterlimit):
+
+        phi = phim1 * (df['VH'] - df['VL'])
+        df['V1'] = df['VL'] + phi
+        df['V2'] = df['VH'] - phi
+
+        df['f1'] = func(df, 'V1')
+        df['f2'] = func(df, 'V2')
+        df['SW_Flag'] = df['f1'] > df['f2']
+
+        df['VL'] = df['V2']*df['SW_Flag'] + df['VL']*(~df['SW_Flag'])
+        df['VH'] = df['V1']*~df['SW_Flag'] + df['VH']*(df['SW_Flag'])
+
+        err = abs(df['V2'] - df['V1'])
+
+        # works with single value because err is np.float64
+        converged = (err[~np.isnan(err)] < atol).all()
+        # err will be less than atol before iterations hit the limit
+        # but just to be safe
+        iterations += 1
